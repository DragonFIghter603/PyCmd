# Wrapped from cmd.py to cmd.py
# md5-hash=ffa2ac21ab63eaec71d73933b18e092
with open("cmd.py", "w") as dest:
dest.write("import json\nimport os\nimport re\nimport sys\n\n\nversion = '1.10.4'\n\n\ncommands = {}\n\n\ndef splitstr(string: str, sep=None, max=None):\n    if sep is None:\n        substr = string.split()\n    else:\n        substr = string.split(sep=sep)\n    if max is None:\n        return substr\n    result = substr[:max]\n    result.append((' ' if sep is None else sep).join(substr[max:]))\n    return result\n\n\ndef table(data, cgettr):\n    if len(data) == 0:\n        return ''\n    columns = []\n    m = []\n    for c in cgettr:\n        columns.append([c(d) for d in data])\n        m.append(max([len(c) for c in columns[-1]]))\n    return '\\n'.join(\n        ' '.join(f'{columns[r][i]:<{m[r]}}' for r in range(len(columns))) for i in range(len(columns[0])))\n\n\nclass Command:\n    def __init__(self, name, argnr, func, register=True, arg_str=''):\n        self.name = name\n        self.argnr = argnr\n        self.func = func\n        self.sub_commands = {}\n        self.arg_str = arg_str\n        if register:\n            commands[name] = self\n\n    def execute(self, args):\n        if len(self.sub_commands) > 0:\n            assert len(args) > 0, f'No subcommand specified for \"{self.name}\"\\nExpected [{\"|\".join(self.sub_commands)}]'\n            if args[0] in self.sub_commands:\n                self.sub_commands[args[0]].execute(args[1:])\n                return\n            else:\n                raise Exception(f'Unknown sub command \"{args[0]}\" for \"{self.name}\".\\nExpected [{\"|\".join(self.sub_commands)}]')\n        if self.func is None:\n            raise Exception(f'Invalid command \"{self.name}\"')\n        if isinstance(self.argnr, int):\n            assert len(args) == self.argnr, f'Expected {self.argnr} args, got {len(args)}'\n        if isinstance(self.argnr, tuple):\n            assert self.argnr[0] <= len(args) <= self.argnr[1], f'Expected {self.argnr[0]} to {self.argnr[1]} args, got {len(args)} '\n        self.func(*args)\n\n\nclass SubCommand(Command):\n    def __init__(self, name, argnr, func, command, arg_str=''):\n        super().__init__(name, argnr, func, register=False, arg_str=arg_str)\n        self.command: Command = command\n        self.command.sub_commands[name] = self\n\n\ndef humanbytes(B):\n    B = float(B)\n    KB = float(1024)\n    MB = float(KB ** 2)  # 1,048,576\n    GB = float(KB ** 3)  # 1,073,741,824\n    TB = float(KB ** 4)  # 1,099,511,627,776\n\n    if B < KB:\n        return '{0}'.format(B), 'B'\n    elif KB <= B < MB:\n        return '{0:.2f}'.format(B / KB), 'KB'\n    elif MB <= B < GB:\n        return '{0:.2f}'.format(B / MB), 'MB'\n    elif GB <= B < TB:\n        return '{0:.2f}'.format(B / GB), 'GB'\n    elif TB <= B:\n        return '{0:.2f}'.format(B / TB), 'TB'\n\n\ndef isfile(path):\n    # if that doesnt work, back to good old try/except OSError - open(path, 'r')\n    return os.stat(path)[-1] != 0\n\n\ndef walk(path, go_deep):\n    path = '.' if path is None else path\n    d = os.getcwd()\n    os.chdir(path)\n    files = os.listdir()\n    print(f'{\"Walk through\" if go_deep else \"Contents of\"} \"{os.getcwd()}\":')\n    print('')\n    listf = []\n\n    def subdir(path, indent):\n        fs = os.listdir(path)\n        lfs = []\n        i = 0\n        for F in fs:  # \u00e2\u201d\u201a \u00e2\u20ac\u201d \u00e2\u201d\u201d \u00e2\u201d\u0153   <->  | - L |\n            listf.append((path + '/' + F, '|   ' * indent + ('L--' if i == len(fs) - 1 else '|--') + ' ' + F))\n            if not isfile(path + '/' + F):\n                listf.extend(subdir(path + '/' + F, indent + 1))\n            i += 1\n        return lfs\n\n    x = 0\n    for f in files:\n        listf.append((f, f))\n        if not isfile(f) and go_deep:\n            listf.extend(subdir(os.getcwd() + '/' + f, 1))\n        x += 1\n\n    if len(files) > 0:\n        print(table([(c[1], isfile(c[0]), humanbytes(os.stat(c[0])[6])) for c in listf],\n                    (lambda c: c[0],\n                     lambda c: f' {(c[0].split(\".\")[-1] if len(c[0].split(\".\")) > 1 else \" \")}' if c[1] else ' ',\n                     lambda c: ' file' if c[1] else ' dir',\n                     lambda c: ' ' + c[2][0],\n                     lambda c: c[2][1])))\n    else:\n        print('This folder is empty')\n    os.chdir(d)\n\n\ndef cat(file: str):\n    print(f'Contents of \"{os.getcwd()}{\"/\" if len(os.getcwd()) > 1 else \"\"}{file}\":')\n    print()\n    with open(file, 'r') as read:\n        print(''.join(read.readlines()))\n    print()\n\n\ndef mkf(file: str):\n    with open(file, 'w'):\n        pass\n\n\nCommand('cd', 1, os.chdir, arg_str='<dir>')\nCommand('walk', (0, 1), lambda x=None: walk(x, True), arg_str='(<dir>)')\nCommand('dir', (0, 1), lambda x=None: walk(x, False), arg_str='(<dir>)')\nCommand('cat', 1, cat, arg_str='<file>')\nCommand('mkdir', 1, os.mkdir, arg_str='<dir>')\nCommand('rmdir', 1, os.rmdir, arg_str='<dir>')\nCommand('mkf', 1, mkf, arg_str='<file>')\nCommand('rename', 2, os.rename, arg_str='<old_fname> <new_fname>')\nCommand('rmf', 1, os.remove, arg_str='<file>')\nCommand('sys', 0, lambda: print(os.uname()))\nCommand('ver', 0, lambda: print(version))\nCommand('pyver', 0, lambda: print(sys.version))\nCommand('pyimp', 0, lambda: print(sys.implementation))\nCommand('help', 0, lambda: print(table(list(commands.values()), (lambda c: c.name,\n                                                            lambda c: (str(c.argnr) if c.arg_str == '' and c.argnr != 0 else c.arg_str) if len(c.sub_commands) == 0 else f'[{\"|\".join(c.sub_commands.keys())}]'))))\nCommand('cd', 1, os.chdir, arg_str='<dir>')\nCommand('exit', 0, sys.exit)\nCommand('run', (1, 255), lambda *x: run(' '.join(x)), arg_str='<command>')\n\nCommand('eval', (1, 255), lambda *x: print(eval(' '.join(x))), arg_str='<expr>')\nCommand('exec', (1, 255), lambda *x: exec(' '.join(x)), arg_str='<command>')\n\n# exec NAME execfile(\"path/to/foo.py\")\n# py NAME function(or=import)\n# run NAME walk\nboot = Command('boot', (1, 255), None)\nSubCommand('list', 0, lambda: print('List of all boot commands scripts: \\n\\n' + table(get_boots(),\n                              (lambda c: c[0].split('/')[0],\n                               lambda c: c[0].split('/')[1] if len(c[0].split('/')) == 2 else '',\n                               lambda c: '  '+c[1],\n                               lambda c: '  '+c[2]))), boot)\n\nSubCommand('refresh', 0, lambda: update_boot(), boot)\n\nadd_boot_cmd = SubCommand('add', 3, None, boot)\nSubCommand('exec', (2, 255), lambda *x: add_boot('exec', ' '.join(x)), add_boot_cmd)\nSubCommand('py', (2, 255), lambda *x: add_boot('py', ' '.join(x)), add_boot_cmd)\nSubCommand('run', (2, 255), lambda *x: add_boot('run', ' '.join(x)), add_boot_cmd)\n\nupdate_boot_cmd = SubCommand('update', 3, None, boot)\nSubCommand('exec', (2, 255), lambda *x: add_boot('exec', ' '.join(x), is_update=True), update_boot_cmd)\nSubCommand('py', (2, 255), lambda *x: add_boot('py', ' '.join(x), is_update=True), update_boot_cmd)\nSubCommand('run', (2, 255), lambda *x: add_boot('run', ' '.join(x), is_update=True), update_boot_cmd)\n\nSubCommand('remove', 1, lambda x: remove_boot(x), boot)\nSubCommand('order', 2, lambda x, o: boot_order(x, o), boot)\n\n\ndef get_boots():\n    with open('/.boot', 'r') as dotboot:\n        return sorted([splitstr(line.strip(), max=2) for line in dotboot.readlines()],\n                      key=lambda x: int(x[0].split('/')[1]) if len(x[0].split('/')) == 2 else 0)\n\n\ndef boot_order(boot_name, order):\n    boot_name = boot_name.upper()\n    boots = get_boots()\n    i = 0\n    for b in boots:\n        if b[1] == boot_name:\n            boots[i][0] = f'{boots[i][0].split(\"/\")[0]}/{order}'\n            with open('/.boot', 'w') as bootfile:\n                for line in [' '.join(b) for b in boots]:\n                    bootfile.write(line + '\\n')\n            update_boot()\n            break\n        i += 1\n    else:\n        raise Exception(f'Could not set order of boot command \"{boot_name}\" as no boot has that name')\n\n\ndef add_boot(b_type: str, command: str, is_update=False):\n    new_boot = splitstr(command, max=1)\n    boot_name = new_boot[0].upper()\n    boots = get_boots()\n    if is_update:\n        i = 0\n        for b in boots:\n            if b[1] == boot_name:\n                the_boot = boots.pop(i)\n                break\n            i += 1\n        else:\n            raise Exception(f'Could not remove boot command \"{boot_name}\" as no boot has that name')\n    regex = '^[A-Za-z_][A-Za-z0-9_]*'\n    assert re.search(regex, boot_name), f'Invalid boot command name \"{boot_name}\"'\n    assert boot_name not in [b[1] for b in boots], f'Boot command \"{boot_name}\" already exists'\n    b_type += ('/'+new_boot[0].split('/')[1]) if len(new_boot[0].split('/')) == 2 else ''\n    boots.append([b_type, boot_name, new_boot[1]])\n    with open('/.boot', 'w') as bootfile:\n        for line in [' '.join(b) for b in boots]:\n            bootfile.write(line+'\\n')\n    update_boot()\n\n\ndef remove_boot(boot_name: str):\n    boot_name = boot_name.upper()\n    boots = get_boots()\n    i = 0\n    for b in boots:\n        if b[1] == boot_name:\n            boots.pop(i)\n            with open('/.boot', 'w') as bootfile:\n                for line in [' '.join(b) for b in boots]:\n                    bootfile.write(line + '\\n')\n            update_boot()\n            break\n        i += 1\n    else:\n        raise Exception(f'Could not remove boot command \"{boot_name}\" as no boot has that name')\n\n\ndef update_boot():\n    with open('/.boot') as bootfile:\n        scripts = [splitstr(line.strip(), max=2) for line in bootfile.readlines()]\n    with open('/entrypoint.py', 'w') as entry:\n        entry.write('from cmd import run\\n\\n')\n        if len(scripts) == 0:\n            entry.write(f'# No boot commands were found\\n')\n        else:\n            entry.write(f'# Executing {len(scripts)} boot commands on boot\\n')\n            for script in scripts:\n                entry.write(f'# {\"   \".join(script)}\\n')\n                type_ = script[0].split('/')[0]\n                if type_ == 'py':\n                    entry.write(f'{script[2]}\\n')\n                if type_ == 'exec':\n                    entry.write(f'execfile({json.dumps(script[2])})\\n')\n                if type_ == 'run':\n                    entry.write(f'run({json.dumps(script[2])})\\n')\n\n\ndef cmd():\n    print(f'hi from cmd.py v{version}')\n    while True:\n        run(input(f'{os.getcwd()}>'))\n\n\ndef run(cmd_):\n    args = cmd_.split()\n    try:\n        if args[0] in commands:\n            commands[args[0]].execute(args[1:])\n        else:\n            raise Exception(f'unknown command \"{args[0]}\"')\n    except Exception as e:\n        print(f'Encountered exception while executing \"{args[0]}\":')\n        print(f'    {type(e).__name__}: {e}')\n\n\nif __name__ == '__main__':\n    cmd()\n")
